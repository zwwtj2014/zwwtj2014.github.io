<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Clam&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://fdconsole.com/"/>
  <updated>2018-07-12T17:14:56.469Z</updated>
  <id>http://fdconsole.com/</id>
  
  <author>
    <name>clam</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>vue中的flowtype--js静态类型检查工具</title>
    <link href="http://fdconsole.com/2018/07/13/vue%E4%B8%AD%E7%9A%84flowtype-js%E9%9D%99%E6%80%81%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5%E5%B7%A5%E5%85%B7/"/>
    <id>http://fdconsole.com/2018/07/13/vue中的flowtype-js静态类型检查工具/</id>
    <published>2018-07-12T17:11:16.000Z</published>
    <updated>2018-07-12T17:14:56.469Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前述"><a href="#前述" class="headerlink" title="前述"></a>前述</h2><p>最近想抽点时间看下<code>Vue</code>的源码，发现Vue是通过<a href="https://flow.org/en/" target="_blank" rel="noopener">Flowtype</a>来做静态检查的，平时用的TS的比较多，所以花了点时间来研究下了Flow，在此做下记录。下面会涉及Flow的一些概念和基本用法，vscode集成flow及开发vue项目的一些配置。</p><p>至于Vue为什么选择Flow而没用TS，尤大在<a href="https://www.zhihu.com/question/46397274" target="_blank" rel="noopener">这个提问</a>中回答了一下，主要是一个成本和收益的考虑，基于已经存在的ES工程(Vue1.x)，通过使用eslint和babel来集成Flow肯定比用TS改写成本小很多。</p><h2 id="vscode集成Flow"><a href="#vscode集成Flow" class="headerlink" title="vscode集成Flow"></a>vscode集成Flow</h2><p>vscode默认是对ts友好的，所以用vscode去写ts可以认为天生就应该这么做的。那vscode如何去集成flow对es做静态检查呢？</p><blockquote><ol><li><p>安装<code>Flow Language Support</code>插件，安装完vscode会提示找不到flow bin的path</p></li><li><p>安装<code>flow-bin</code>，可以全局安装，也可以工程级安装，这里我们选择前者 <code>npm install -g flow-bin</code></p></li><li>关闭vscode自带的es校验机制：<code>&quot;javascript.validate.enable&quot;: false</code>，这个是vscode自身的配置，可以是用户级别，也可以是当前工程级</li></ol></blockquote><p>按照上述三步操作之后，你的vscode现在对es就是使用flowtype进行校验了。</p><h2 id="Flow-基本用法"><a href="#Flow-基本用法" class="headerlink" title="Flow 基本用法"></a>Flow <a href="https://flow.org/en/docs/" target="_blank" rel="noopener">基本用法</a></h2><p>对于一个工程，我们需要flow的配置文件<code>.flowconfig</code>，可以手动建，也可以通过<code>flow init</code>自动生成，该文件中是对当前工程如何检查的一些配置，如<code>ignore</code>,<code>include</code>,<code>libs</code>,<code>options</code>等等，具体的配置可以参见<a href="https://flow.org/en/docs/config/" target="_blank" rel="noopener">How to configure Flow</a></p><p>对于要校验的es文件，需要在开头使用 <code>/*@flow*/</code> 或者 <code>// @flow</code> 来标识，从而告诉Flow 这个文件可以来检查了，如果没这个标识，Flow检查的时候会忽略对应的文件。</p><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><h4 id="类型定义及相关的推断"><a href="#类型定义及相关的推断" class="headerlink" title="类型定义及相关的推断"></a>类型定义及相关的推断</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @flow</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">concat</span>(<span class="params">a: string, b: string</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">concat(<span class="string">"A"</span>, <span class="string">"B"</span>); <span class="comment">// Works!</span></span><br><span class="line">concat(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// Error!</span></span><br></pre></td></tr></table></figure><h4 id="支持Array-类型"><a href="#支持Array-类型" class="headerlink" title="支持Array 类型"></a>支持Array 类型</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr: <span class="built_in">Array</span>&lt;number&gt; = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> arr: number[] = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> arr1: <span class="built_in">Array</span>&lt;boolean&gt; = [<span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">true</span>];</span><br><span class="line"><span class="keyword">let</span> arr2: <span class="built_in">Array</span>&lt;string&gt; = [<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>];</span><br><span class="line"><span class="keyword">let</span> arr3: <span class="built_in">Array</span>&lt;mixed&gt; = [<span class="number">1</span>, <span class="literal">true</span>, <span class="string">"three"</span>]</span><br></pre></td></tr></table></figure><h4 id="支持Class类型"><a href="#支持Class类型" class="headerlink" title="支持Class类型"></a>支持Class类型</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @flow</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">  prop: number;</span><br><span class="line">  method(value: string): number &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>&lt;<span class="title">A</span>, <span class="title">B</span>, <span class="title">C</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(arg1: A, arg2: B, arg3: C) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> val: MyClass&lt;number, boolean, string&gt; = <span class="keyword">new</span> MyClass(<span class="number">1</span>, <span class="literal">true</span>, <span class="string">'three'</span>);</span><br></pre></td></tr></table></figure><p>上述简单的列了几种，详细的可以参见 <a href="https://flow.org/en/docs/types/" target="_blank" rel="noopener">how to add type annotations to your code </a> .</p><p>可以看到支持的场景和TS的类型定义有的一拼，所以Flow对于ES检查应该很完善了。</p><h2 id="Flow-在-Vue-的应用"><a href="#Flow-在-Vue-的应用" class="headerlink" title="Flow 在 Vue 的应用"></a>Flow 在 Vue 的应用</h2><p>在vue中，静态检查是依托flow的，并通过配和babel插件<code>babel-plugin-transform-flow-strip-types</code>，在编译的过程中移除flow的语法，变成纯粹可运行的JS代码，相比ts到js的转换来说还是相对要轻量很多的。</p><p>在vue的根目录下有一个flow的<a href="https://github.com/vuejs/vue/blob/dev/.flowconfig" target="_blank" rel="noopener">配置文件</a>，内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[ignore]</span><br><span class="line">.*/node_modules/.*</span><br><span class="line">.*/test/.*</span><br><span class="line">.*/scripts/.*</span><br><span class="line">.*/examples/.*</span><br><span class="line">.*/benchmarks/.*</span><br><span class="line"></span><br><span class="line">[include]</span><br><span class="line"></span><br><span class="line">[libs]</span><br><span class="line">flow</span><br><span class="line"></span><br><span class="line">[options]</span><br><span class="line">unsafe.enable_getters_and_setters=true</span><br><span class="line">module.name_mapper=&apos;^compiler/\(.*\)$&apos; -&gt; &apos;&lt;PROJECT_ROOT&gt;/src/compiler/\1&apos;</span><br><span class="line">module.name_mapper=&apos;^core/\(.*\)$&apos; -&gt; &apos;&lt;PROJECT_ROOT&gt;/src/core/\1&apos;</span><br><span class="line">module.name_mapper=&apos;^shared/\(.*\)$&apos; -&gt; &apos;&lt;PROJECT_ROOT&gt;/src/shared/\1&apos;</span><br><span class="line">module.name_mapper=&apos;^web/\(.*\)$&apos; -&gt; &apos;&lt;PROJECT_ROOT&gt;/src/platforms/web/\1&apos;</span><br><span class="line">module.name_mapper=&apos;^weex/\(.*\)$&apos; -&gt; &apos;&lt;PROJECT_ROOT&gt;/src/platforms/weex/\1&apos;</span><br><span class="line">module.name_mapper=&apos;^server/\(.*\)$&apos; -&gt; &apos;&lt;PROJECT_ROOT&gt;/src/server/\1&apos;</span><br><span class="line">module.name_mapper=&apos;^entries/\(.*\)$&apos; -&gt; &apos;&lt;PROJECT_ROOT&gt;/src/entries/\1&apos;</span><br><span class="line">module.name_mapper=&apos;^sfc/\(.*\)$&apos; -&gt; &apos;&lt;PROJECT_ROOT&gt;/src/sfc/\1&apos;</span><br><span class="line">suppress_comment= \\(.\\|\n\\)*\\$flow-disable-line</span><br></pre></td></tr></table></figure><blockquote><p><strong>[ignore]: </strong>这个配置项很常见，用于忽略匹配的文件。支持配置正则，且优先级高于include。具体配置详见 <a href="https://flow.org/en/docs/config/ignore/" target="_blank" rel="noopener">How to configure Flow to ignore certain files </a></p><blockquote><p>上面的配置的意思是 <code>node_modules</code> <code>test</code>  <code>scripts</code> <code>examples</code> <code>benchmarks</code> 目录下的所有子目录及文件都会被忽略</p></blockquote></blockquote><blockquote><p><strong>[include]：</strong>这个配置和<code>ignore</code>是相对的，支持配置绝对路径和相对路径，并且支持<code>*</code>和<code>**</code>通配符。具体配置详见 <a href="https://flow.org/en/docs/config/include/" target="_blank" rel="noopener">How to configure Flow to include certain files </a></p></blockquote><blockquote><p><strong>[libs]：</strong>在Flow中用户可以自定义一些类型或者引用第三方库。通过自定义类型，就可以对一些复杂类型做约束，在类型检查的时候不会报错，有点像ts中的types和type定义类型。而libs就是用来描述这些自定义类型所存放的目录，默认目录名是<code>flow-typed</code></p><blockquote><p><code>Vue</code>中配置的是<code>flow</code>，打开flow目录，我们可以看到下面的文件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; &gt; flow</span><br><span class="line">&gt; &gt; ├── compiler.js    # 编译相关: CompilerOptions;CompiledResult;ModuleOptions等等</span><br><span class="line">&gt; &gt; ├── component.js   # 组件的数据结构: Component</span><br><span class="line">&gt; &gt; ├── global-api.js  # Global API 结构: GlobalAPI</span><br><span class="line">&gt; &gt; ├── modules.js     # 第三方库定义, 比如source-map, lru-cache等</span><br><span class="line">&gt; &gt; ├── options.js     # 选项相关: InternalComponentOptions;ComponentOptions;PropOptions</span><br><span class="line">&gt; &gt; ├── ssr.js         # 服务端渲染: ComponentWithCacheContext;ElementContext;ComponentContext</span><br><span class="line">&gt; &gt; ├── vnode.js       # 虚拟 node 相关: VNodeComponentOptions;VNodeData;VNodeDirective</span><br><span class="line">&gt; &gt; ├── weex.js        # weex 相关: Weex;WeexConfigAPI;WeexEnvironment;WeexDocument</span><br><span class="line">&gt; &gt;</span><br></pre></td></tr></table></figure></blockquote></blockquote><blockquote><blockquote><p>这些定义对于读源码来说是必不可少的。</p></blockquote></blockquote><blockquote><p><strong>[options]: </strong> flow暴露出来的很多很有意思的配置项，如果没有指定的话就使用默认值。具体的配置项详见 <a href="https://flow.org/en/docs/config/options/" target="_blank" rel="noopener">How to configure Flow’s various options </a></p><blockquote><p><code>Vue</code>中的配置了有项，具体的含义如下：</p><blockquote><p><code>module.name_mapper</code>:  格式是 <code>module.name_mapper= regex -&gt; string</code>，作用是告诉flow遇到require(regex)时，用require(string)替代。</p><p><strong>举例</strong> </p><blockquote><p>配置：<code>module.name_mapper=&#39;^compiler/\(.*\)$&#39; -&gt; &#39;&lt;PROJECT_ROOT&gt;/src/compiler/\1&#39;</code></p><p>含义：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; &gt; &gt; &gt; <span class="keyword">import</span> &#123;  getAndRemoveAttr &#125; <span class="keyword">from</span> <span class="string">'compiler/helpers'</span></span><br><span class="line">&gt; &gt; &gt; &gt; <span class="comment">// 等价于</span></span><br><span class="line">&gt; &gt; &gt; &gt; <span class="keyword">import</span> &#123;  getAndRemoveAttr &#125; <span class="keyword">from</span> <span class="string">'&lt;PROJECT_ROOT&gt;/src/compiler/helpers'</span><span class="string">`</span></span><br><span class="line"><span class="string">&gt; &gt; &gt; &gt;</span></span><br></pre></td></tr></table></figure></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><p><code>unsafe.enable_getters_and_setters=true</code>: 意思很清楚，就是表示开启支持getter和setter方法。<strong>这个选项在<code>0.62.0</code>及以后已经移除了，并且默认开启的，所以如果你用的Flow版本比较新就不用配了</strong></p></blockquote><blockquote><p><code>suppress_comment</code>: 这个可选项的作用是配置一个规则，符合这个规则的注释下的语句不会报Flow错误，和eslint中的<code>eslint-disable-next-line</code>类似，对于一些需要重构的代码非常有用。</p></blockquote></blockquote></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>学习和初步使用了一下Flow，对于经常使用TS的我来说还是感觉很亲切的。功能很完善也很强大，配合eslint和babel来使用又不会过于复杂，对于ES工程是一个很好的选择，不用过于纠结ES没有类型检查的问题。</p><h4 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h4><p><a href="https://flow.org/en/" target="_blank" rel="noopener">Flow 官网</a></p><p><a href="https://www.zhihu.com/question/46397274" target="_blank" rel="noopener">Vue 2.0 为什么选用 Flow 进行静态代码检查而不是直接使用 TypeScript？</a></p><p><a href="https://ustbhuangyi.github.io/vue-analysis/prepare/flow.html#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8-flow" target="_blank" rel="noopener">认识 Flow</a></p><p><a href="http://orchidflower.gitee.io/2017/04/11/Using-flow-js-for-vue-in-VSCode/" target="_blank" rel="noopener">在VSCode中为Vue.js开发启用静态类型检查Flow</a></p>]]></content>
    
    <summary type="html">
    
      Flow是Facebook出品的，针对JavaScript的静态类型检查工具，遵守BSD开源协议。Vue采用了Flow作为静态检查的工具。
    
    </summary>
    
      <category term="ES" scheme="http://fdconsole.com/categories/ES/"/>
    
    
      <category term="javascript" scheme="http://fdconsole.com/tags/javascript/"/>
    
      <category term="flow" scheme="http://fdconsole.com/tags/flow/"/>
    
  </entry>
  
  <entry>
    <title>读源码之Connect-v3.6.7</title>
    <link href="http://fdconsole.com/2018/06/10/%E8%AF%BB%E6%BA%90%E7%A0%81%E4%B9%8BConnect-v3.6.7/"/>
    <id>http://fdconsole.com/2018/06/10/读源码之Connect-v3.6.7/</id>
    <published>2018-06-10T13:17:18.000Z</published>
    <updated>2018-06-10T13:23:01.998Z</updated>
    
    <content type="html"><![CDATA[<p>Connect 库代码并不复杂，核心的逻辑200行左右，核心的功能就是提供了插入中间件的hook，然后串联中间件函数对请求和响应对象进行处理。</p><h4 id="代码库：https-github-com-senchalabs-connect"><a href="#代码库：https-github-com-senchalabs-connect" class="headerlink" title="代码库：https://github.com/senchalabs/connect"></a>代码库：<a href="https://github.com/senchalabs/connect" target="_blank" rel="noopener">https://github.com/senchalabs/connect</a></h4><p><strong>首先是导出总结构：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> proto = &#123;&#125;;</span><br><span class="line"><span class="built_in">module</span>.exports = createServer; <span class="comment">// 导出的是一个function</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createServer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">app</span>(<span class="params">req, res, next</span>)</span>&#123; <span class="comment">/**/</span> &#125; <span class="comment">// 真正的app对象，作为`http.createServer`的回调创建server用</span></span><br><span class="line">  merge(app, proto); <span class="comment">// merger 的功能是把proto上的属性和值copy到app上</span></span><br><span class="line">  merge(app, EventEmitter.prototype); <span class="comment">// 使app有事件的能力</span></span><br><span class="line">  app.route = <span class="string">'/'</span>; <span class="comment">// 默认的route</span></span><br><span class="line">  app.stack = []; <span class="comment">// 存储中间件， 结构是&#123;route, handle&#125;</span></span><br><span class="line">  <span class="keyword">return</span> app; <span class="comment">// 返回真正的app对象，上面挂载了所有的方法和属性</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>常用的几个方法</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">proto.use = <span class="function"><span class="keyword">function</span>(<span class="params">route, fn</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 判断场景：route有没有传进来? fn是普通的function还是sub app</span></span><br><span class="line">    <span class="comment">// 这个route也是实现挂载的核心所在</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">this</span>.stack.push(&#123; <span class="attr">route</span>: path, <span class="attr">handle</span>: handle &#125;); <span class="comment">// 记录每个挂载和对应的handle</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 处理请求，顺序匹配对应的中间件，即next</span></span><br><span class="line">proto.handle = <span class="function"><span class="keyword">function</span> <span class="title">handle</span>(<span class="params">req, res, out</span>) </span>&#123;</span><br><span class="line">   <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 处理url: 补齐最后的'/'； 移除挂载，找到真正的请求的url（这地方要注意）</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">var</span> layer = stack[index++];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// all done</span></span><br><span class="line">        <span class="keyword">if</span>(!layer)&#123;</span><br><span class="line">            defer(done, err);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// call the layer handle</span></span><br><span class="line">    call(layer.handle, route, err, req, res, next);</span><br><span class="line">    &#125;</span><br><span class="line">    next();<span class="comment">// 初始执行</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据handle的参数个数塞对应的参数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">call</span>(<span class="params">handle, route, err, req, res, next</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> hasError = <span class="built_in">Boolean</span>(err); <span class="comment">// 通过hasError实现当出现error的时候跳过所有普通的handle</span></span><br><span class="line">    <span class="keyword">var</span> arity = handle.length; <span class="comment">// 获取handle的参数个数，用于匹配第一个参数是不是err</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (hasError &amp;&amp; arity === <span class="number">4</span>) &#123; <span class="comment">// 带err的4个参数的中间件</span></span><br><span class="line">            <span class="comment">// error-handling middleware</span></span><br><span class="line">            handle(err, req, res, next);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!hasError &amp;&amp; arity &lt; <span class="number">4</span>) &#123; <span class="comment">// 不带err的3个参数的中间件</span></span><br><span class="line">            <span class="comment">// request-handling middleware</span></span><br><span class="line">            handle(req, res, next);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123; <span class="comment">// 没带err但是报错会走的逻辑</span></span><br><span class="line">        <span class="comment">// replace the error</span></span><br><span class="line">        error = e;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    next(error);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建server</span></span><br><span class="line">proto.listen = <span class="function"><span class="keyword">function</span> <span class="title">listen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> server = http.createServer(<span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">return</span> server.listen.apply(server, <span class="built_in">arguments</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>因为返回的app的参数格式是可以，所以我们可以用两种方式来创建server：<code>app.listen(3000)</code> ; <code>http.createServer(app).listen(3000)</code></li><li>app是支持事件的</li><li>中间件的handle是支持sub-app的</li><li>当出现错误时，后续所有非错误处理中间件都会过滤掉</li></ul>]]></content>
    
    <summary type="html">
    
      Connect 是一个框架，它使用被称为中间件的模块化函数，以可重用的方式实现Web程序中的逻辑。中间件指的是一个函数，它拦截HTTP服务器提供的请求和响应对象，然后直接逻辑，最后结束响应，或者把它传递给下一个中间件组件。在Connect中，使用分派器将中间件连接在一起。
    
    </summary>
    
      <category term="读源码" scheme="http://fdconsole.com/categories/%E8%AF%BB%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="读源码" scheme="http://fdconsole.com/tags/%E8%AF%BB%E6%BA%90%E7%A0%81/"/>
    
      <category term="Connect" scheme="http://fdconsole.com/tags/Connect/"/>
    
  </entry>
  
  <entry>
    <title>node模块 —— 实现功能组织和重用</title>
    <link href="http://fdconsole.com/2018/06/05/node%E6%A8%A1%E5%9D%97-%E2%80%94%E2%80%94-%E5%AE%9E%E7%8E%B0%E5%8A%9F%E8%83%BD%E7%BB%84%E7%BB%87%E5%92%8C%E9%87%8D%E7%94%A8/"/>
    <id>http://fdconsole.com/2018/06/05/node模块-——-实现功能组织和重用/</id>
    <published>2018-06-05T15:14:27.000Z</published>
    <updated>2018-06-05T15:17:06.599Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Node的模块"><a href="#Node的模块" class="headerlink" title="Node的模块"></a>Node的模块</h2><p>Node是通过模块(module) 的概念来实现功能的组织和重用的。Node模块允许你从被引入文件中选择要暴露给程序的函数和变量，主要是通过<code>require</code>和<code>exports</code>两个关键字。<strong>如果模块返回的函数或变量不止一个，那它可以通过设定<code>exports对象</code>的属性来指明它们。但是如果模块只返回一个函数或变量。则可以设定<code>module.exports</code>属性</strong>。</p><h4 id="同步IO的require"><a href="#同步IO的require" class="headerlink" title="同步IO的require"></a>同步IO的<code>require</code></h4><p>require在node中被设计成了同步I/O，因为在服务器端文件一般都是存放在本地磁盘上，所以性能是OK的。但是在IO密集的地方还是要注意尽量不要使用，所以在使用commonjs的时候要慎重，所有的同步都会阻塞注进程。</p><h4 id="exports对象-VS-module-exports"><a href="#exports对象-VS-module-exports" class="headerlink" title="exports对象 VS module.exports"></a><code>exports对象</code> VS <code>module.exports</code></h4><p>要明白在程序中最终导出的<code>module.exports</code>，<strong>与<code>require</code>对接的也是<code>module.exports</code></strong>。你可以认为<code>exports</code>只是对<code>module.exports</code>的一个全局引用，最初被定义成一个可以添加属性的空对象。简单理解：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> exports = <span class="built_in">module</span>.exports;</span><br><span class="line">exports.myFunc === <span class="built_in">module</span>.exports.myFunc; <span class="comment">// 相等</span></span><br></pre></td></tr></table></figure><p>对于上述代码无论怎么给exports设置属性<code>exports.xxx</code>都是OK的，因为它和<code>module.exports</code>引用的同一块地址，但是如果<code>exports = {xxx}</code>就会改变<code>exports</code>的指向，不管给它设置啥值，在<code>module.exports</code>都是感知不到的，进而<code>require</code>就感知不到我们想导出的任何方法。</p><p><strong>所以我们说，多个导出值时可以使用exports属性的方法，耽搁函数变量的时候可以使用<code>module.exports</code>。</strong></p><h4 id="node-modules"><a href="#node-modules" class="headerlink" title="node_modules"></a>node_modules</h4><p>node中有一个独特的模块引入机制，可以不用知道模块在文件系统的具体位置。这个机制就是<strong>node_modules</strong>目。这个机制对于模块重用非常有用，可以大大的减轻用户对依赖的文件的路径管理，只需要知道依赖的包名。正因为其非常易用，导致现在对于滥用的情况，即著名的node_modules黑洞。在最近ry大神介绍deno项目时也提到了这一点。</p><p><strong>查找步骤：</strong></p><blockquote><ol><li>查找的模块时<strong>核心模块</strong>吗？是的话直接返回，不是进入步骤2；</li><li>模块在<strong>当前目录下的node_modules目录</strong>下吗？在的话直接返回，否则进入步骤3；</li><li>尝试进入父目录；</li><li>父目录存在吗？存在的话返回步骤2循环，不存在进入步骤5；</li><li>模块在由环境变量<strong>NODE_PATH</strong>指定的目录下吗？在的话返回，否则进入步骤6；</li><li>抛出异常；</li></ol></blockquote><h4 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h4><ul><li>如果模块时目录，在模块目录中定义模块的文件必须被命令index.js，除非在这个目录的一个叫<code>package.json</code>的文件中通过main字段特别指明</li><li>Node能把模块作为对象缓存起来，这与如果两个文件引入相同的模块，第一个文件会把模块返回的数据存到程序的内存中，这与第二个文件就不用再去访问和计算模块的源文件了。<strong>（注意：在这里第二个引入其实是有机会改缓存的数据的）</strong></li></ul>]]></content>
    
    <summary type="html">
    
      Node是通过模块(module) 的概念来实现功能的组织和重用的。Node模块允许你从被引入文件中选择要暴露给程序的函数和变量，主要是通过`require`和`exports`两个关键字。
    
    </summary>
    
      <category term="读书笔记" scheme="http://fdconsole.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="node实战" scheme="http://fdconsole.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/node%E5%AE%9E%E6%88%98/"/>
    
    
      <category term="读书" scheme="http://fdconsole.com/tags/%E8%AF%BB%E4%B9%A6/"/>
    
  </entry>
  
  <entry>
    <title>package.json 文件中的main和module字段说明</title>
    <link href="http://fdconsole.com/2018/04/19/package-json-%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84main%E5%92%8Cmodule%E5%AD%97%E6%AE%B5%E8%AF%B4%E6%98%8E/"/>
    <id>http://fdconsole.com/2018/04/19/package-json-文件中的main和module字段说明/</id>
    <published>2018-04-19T14:34:59.000Z</published>
    <updated>2018-04-21T14:08:34.189Z</updated>
    
    <content type="html"><![CDATA[<h3 id="main"><a href="#main" class="headerlink" title="main"></a>main</h3><p>关于<code>main</code>，在npm的官网是有专门的说明的：</p><blockquote><p><strong>main</strong></p><p>The main field is a module ID that is the primary entry point to your program. That is, if your package is named <code>foo</code>, and a user installs it, and then does <code>require(&quot;foo&quot;)</code>, then your main module’s exports object will be returned.</p><p>This should be a module ID relative to the root of your package folder.</p><p>For most modules, it makes the most sense to have a main script and often not much else.</p></blockquote><p>翻译一下：main字段表明的是包程序的主要入口。比如你的包名是<code>foo</code>，然后用户install之后，通过<code>require(&#39;foo&#39;)</code>的方式引用你的包，然后<strong>node在resolve模块</strong>的时候找的就是main配置的文件。</p><p>通过<code>require</code>的方式引用应该很容易看出来，该字段主要是用于commonjs的。</p><h3 id="module"><a href="#module" class="headerlink" title="module"></a>module</h3><p>关于module，简单的说其实它是指向一个ESM的入口，比如使用<code>rollup</code>做tree shaking的时候，就需要使用该配置。</p><p>其实在rollup的wiki里有一篇专门说明该字段的文档，里面还说明了<code>jsnext:main</code>和<code>moudle</code>其实等价的，只是后者变为标准，所以后者用的比较多，而且比较直观。摘录一部分如下：</p><blockquote><p><code>pkg.module</code> will point to a module that has <em>ES2015 module syntax</em> but otherwise <em>only syntax features that the target environments support</em>.</p></blockquote><h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><p>这两个字段同时在一个包的时候，就可以实现同一个包有<strong>两个入口</strong>的场景。有时候做前后端串通的时候还是很有用的。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://docs.npmjs.com/files/package.json#main" target="_blank" rel="noopener">package.json # main</a></p><p><a href="https://github.com/rollup/rollup/wiki/pkg.module" target="_blank" rel="noopener">rollup # pkg.module</a></p>]]></content>
    
    <summary type="html">
    
      main字段表明的是包程序的主要入口。module是指向一个ESM的入口
    
    </summary>
    
      <category term="node" scheme="http://fdconsole.com/categories/node/"/>
    
    
      <category term="node" scheme="http://fdconsole.com/tags/node/"/>
    
      <category term="javascript" scheme="http://fdconsole.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>html meta tag 基础</title>
    <link href="http://fdconsole.com/2018/04/18/meta%E6%A0%87%E7%AD%BE%E5%9F%BA%E7%A1%80/"/>
    <id>http://fdconsole.com/2018/04/18/meta标签基础/</id>
    <published>2018-04-18T13:20:36.000Z</published>
    <updated>2018-04-19T14:35:36.839Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Definition"><a href="#Definition" class="headerlink" title="Definition"></a>Definition</h3><blockquote><p><strong>Metadata is data (information) about data.</strong></p><p>The <code>&lt;meta&gt;</code> tag provides metadata about the HTML document. Metadata will not be displayed on the page, but will be machine parsable.</p><p>Meta elements are typically used to specify page description, keywords, author of the document, last modified, and other metadata.</p><p>The metadata can be used by browsers (how to display content or reload page), search engines (keywords), or other web services.</p></blockquote><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><p><strong>charset</strong></p><blockquote><p>此特性声明当前文档所使用的字符编码，但该声明可以被任何一个元素的 <strong>lang</strong> 特性的值覆盖</p><p><code>&lt;meta charset=&quot;utf-8&quot;&gt; //HTML5设定网页字符集的方式，推荐使用UTF-8</code></p></blockquote><p><strong>content</strong></p><blockquote><p>基于内容，这个属性为 <code>http-equiv</code> 或 <code>name</code> 属性提供了与其相关的值的定义.</p></blockquote><p><strong>http-equiv</strong></p><blockquote><p>这个枚举属性定义了能改变服务器和用户引擎行为的编译。相当于http的文件头作用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt; &lt;meta http-equiv="Content-Security-Policy" content="default-src https:"&gt; // 设定内容安全策略</span><br><span class="line">&gt;     </span><br><span class="line">&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"/&gt; //指定IE和Chrome使用最新版本渲染当前页面</span><br><span class="line">&gt;</span><br><span class="line">&gt; &lt;meta http-equiv="expires" content="Wed Apr 18 2018 20:59:01 GMT+0800" /&gt; // 用于设定网页的到期时间，过期后网页必须到服务器上重新传输。</span><br><span class="line">&gt;     </span><br><span class="line">&gt; &lt;meta http-equiv="refresh" content="2;URL=http://fdconsole.com/"&gt; //意思是2秒后跳转向我的博客</span><br><span class="line">&gt;</span><br><span class="line">&gt; &lt;meta http-equiv="Set-Cookie" content="User=clam; path=/; expires=xxx"&gt; //已过时</span><br><span class="line">&gt;     </span><br><span class="line">&gt; &lt;meta http-equiv="content-Type" content="text/html;charset=utf-8"&gt;  //设定网页编码，已过时，推荐上文H5的方式</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p><strong>name</strong></p><blockquote><p>该属性定义文档级别元数据的名称。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt; &lt;meta name="application-name" content="fdconsole"&gt; // 定义正运行在该网页上的网络应用名称</span><br><span class="line">&gt;</span><br><span class="line">&gt; &lt;meta name="author" content="fdconsole"&gt; // 作者名称</span><br><span class="line">&gt;</span><br><span class="line">&gt; &lt;meta name="description" content="fdconsole"&gt; // 包含页面内容的简短和精确的描述</span><br><span class="line">&gt;     </span><br><span class="line">&gt; &lt;meta name="keywords" content="fdconsole,clam"&gt; // 网页的关键字</span><br><span class="line">&gt;     </span><br><span class="line">&gt; &lt;meta name="creator" content="clam"&gt; // 创建者，可以是机构的名称</span><br><span class="line">&gt;     </span><br><span class="line">&gt; &lt;meta name="robots" content="follow"&gt; // 告知搜索引擎的索引方式，用于SEO</span><br><span class="line">&gt;     </span><br><span class="line">&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt; // 提供有关视口初始大小的提示，仅供移动设备使用。</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>其实meta常用的就那几个，很多细节还是需要仔细研究的， 比如SEO相关，cache相关，后续遇到再补充。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.w3schools.com/tags/tag_meta.asp" target="_blank" rel="noopener">w3school HTML <meta> Tag</a></p><p><a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta" target="_blank" rel="noopener">MDN <meta>: The Document-level Metadata element</a></p>]]></content>
    
    <summary type="html">
    
      Metadata is data (information) about data.
    
    </summary>
    
      <category term="HTML" scheme="http://fdconsole.com/categories/HTML/"/>
    
    
      <category term="HTML" scheme="http://fdconsole.com/tags/HTML/"/>
    
      <category term="meta" scheme="http://fdconsole.com/tags/meta/"/>
    
  </entry>
  
  <entry>
    <title>SGML介绍 (翻译)</title>
    <link href="http://fdconsole.com/2018/04/17/SGML%E4%BB%8B%E7%BB%8D/"/>
    <id>http://fdconsole.com/2018/04/17/SGML介绍/</id>
    <published>2018-04-16T16:57:02.000Z</published>
    <updated>2018-04-17T14:32:45.791Z</updated>
    
    <content type="html"><![CDATA[<p>原文：<a href="https://validator.w3.org/docs/sgml.html" target="_blank" rel="noopener">Introduction to SGMLfor the W3C Markup Validator</a></p><h3 id="SGML是什么？"><a href="#SGML是什么？" class="headerlink" title="SGML是什么？"></a>SGML是什么？</h3><p>SGML是 Standard Generalized Markup Language 的缩写。这实际上有一点稍微的不合适，因为SGML实际上是一种<strong>元语言（meta-language）</strong>，即用于编写标记语言的语言。像我们熟知的HTML，在H5以前的版本就是基于SGML的，还有XHTML，XML等。</p><p>实际上并不需要知道很多SGML就可以很好的使用它的校验能力。但是如果你感兴趣，我建议TEI的 <a href="http://www.tei-c.org/Vault/P4/doc/html/SG.html" target="_blank" rel="noopener">SGML简介</a> 可以作为一个很好的起点。想更进一步，可以看看 Martin Bryan 的 <a href="http://www.is-thought.co.uk/book/home.htm" target="_blank" rel="noopener">Web SGML和HTML4.0解释</a>。</p><h3 id="DTD是什么"><a href="#DTD是什么" class="headerlink" title="DTD是什么?"></a>DTD是什么?</h3><p>出于我们的目的，DTD（文档类型定义）只是一个基于SGML定义的一个语法文件。HTML2.0 和 HTML3.2 的DTD是由IETF的HTML工作组与W3C合作撰写的。从 HTML4.0 开始（包含XHTML）是由W3C编写的。</p><h3 id="DOCTYPE-是什么？"><a href="#DOCTYPE-是什么？" class="headerlink" title="DOCTYPE 是什么？"></a>DOCTYPE 是什么？</h3><p><code>DOCTYPE</code>是 SGML 文档类型声明。它存在的目的是告诉SGML解析器应该使用哪种 DTD来解析文档。正常情况下作为文章的第一行显示。并具有以下格式：<code>&lt;!DOCTYPE html PUBLIC &quot;quoted string&quot;&gt;</code>。 其中 “quoted string” 被称为公共标识符，它通过一些熟知的名字来引用 标准的DTD。</p><h3 id="为什么要添加一个DOCTYPE？"><a href="#为什么要添加一个DOCTYPE？" class="headerlink" title="为什么要添加一个DOCTYPE？"></a>为什么要添加一个DOCTYPE？</h3><p>校验的能力是由SGML解释器提供的，而<code>DOCTYPE</code>声明即使不是唯一的方式知道应该验证哪些标记语言，也算是最主要的方式了。</p><p>需要注意的是，实际上大多数的浏览器并没有使用SGML解释器，它们大多数都是通过文档的<code>DOCTYPE</code>声明或是否缺少声明来显示文档内容的。这算是给文档添加声明的好理由吧。(译者注: <code>DOCTYPE</code>指示 web 浏览器关于页面使用哪个 HTML 版本进行编写的指令, HTML5不基于SGML, 所以H5的<code>DOCTYPE</code>不用公共标识符。)</p><p>所以现在我们应该给文档都添加一个<code>DOCTYPE</code>，并且确保语法正确，并且使用正确的公共标识符，否则的话，校验器就会使用错误的DTD，或者根本找不到DTD，从而导致一系列无意义的错误。</p><h3 id="我如何添加DOCTYPE声明？"><a href="#我如何添加DOCTYPE声明？" class="headerlink" title="我如何添加DOCTYPE声明？"></a>我如何添加DOCTYPE声明？</h3><p>可以参见W3C维护的DTD列表，详见 <a href="https://www.w3.org/QA/2002/04/valid-dtd-list.html" target="_blank" rel="noopener">DTD list</a></p><hr><table><thead><tr><th style="text-align:center">HTML版本 &amp; 模式</th><th style="text-align:center">DTD</th></tr></thead><tbody><tr><td style="text-align:center">HTML5 and beyond</td><td style="text-align:center"><code>&lt;!DOCTYPE HTML&gt;</code></td></tr><tr><td style="text-align:center">HTML4.01 &amp; Strict</td><td style="text-align:center"><code>&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot;    &quot;http://www.w3.org/TR/html4/strict.dtd&quot;&gt;</code></td></tr><tr><td style="text-align:center">HTML4.01 &amp; Transitional</td><td style="text-align:center"><code>&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;    &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;</code></td></tr><tr><td style="text-align:center">HTML4.01 &amp; Frameset</td><td style="text-align:center"><code>&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Frameset//EN&quot;     &quot;http://www.w3.org/TR/html4/frameset.dtd&quot;&gt;</code></td></tr><tr><td style="text-align:center">XHTML1.0 &amp; Strict</td><td style="text-align:center"><code>&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Strict//EN&quot;    &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd&quot;&gt;</code></td></tr><tr><td style="text-align:center">XHTML1.0 &amp; Frameset</td><td style="text-align:center"><code>&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot;    &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;</code></td></tr><tr><td style="text-align:center">XHTML1.0 &amp; Frameset</td><td style="text-align:center"><code>&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Frameset//EN&quot;   &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd&quot;&gt;</code></td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      SGML是 Standard Generalized Markup Language 的缩写。这实际上有一点稍微的不合适，因为SGML实际上是一种元语言（meta-language），即用于编写标记语言的语言。像我们熟知的HTML，在H5以前的版本就是基于SGML的，还有XHTML，XML等。
    
    </summary>
    
      <category term="HTML" scheme="http://fdconsole.com/categories/HTML/"/>
    
    
      <category term="W3C" scheme="http://fdconsole.com/tags/W3C/"/>
    
      <category term="SGML" scheme="http://fdconsole.com/tags/SGML/"/>
    
  </entry>
  
  <entry>
    <title>常用的node库——gulp</title>
    <link href="http://fdconsole.com/2018/03/28/%E5%B8%B8%E7%94%A8%E7%9A%84node%E5%BA%93%E2%80%94%E2%80%94gulp/"/>
    <id>http://fdconsole.com/2018/03/28/常用的node库——gulp/</id>
    <published>2018-03-28T14:32:48.000Z</published>
    <updated>2018-03-28T14:35:26.092Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>gulp是基于Node的前端构建工具。将源到目标的编译构建按照流的思想任务化，正如其官网所说，gulp让简单的任务简单，让复杂的任务可管理。</p><h2 id="基础使用"><a href="#基础使用" class="headerlink" title="基础使用"></a>基础使用</h2><p><strong>1. 安装</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install -g gulp // 全局安装</span><br><span class="line">npm install -D gulp // 开发态依赖</span><br></pre></td></tr></table></figure><p><strong>2. 使用</strong></p><ul><li><p>在项目根目录新建<code>gulpfile.js</code>，内容格式如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>);</span><br><span class="line">gulp.task(<span class="string">'default'</span>, ()=&gt;&#123;</span><br><span class="line">    <span class="comment">// 任务代码</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'default task'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gulp // 执行gulpfile.js文件</span><br><span class="line">===&gt; default task</span><br><span class="line"></span><br><span class="line">gulp &lt;task&gt; &lt;othertask&gt; // 执行特定的任务</span><br></pre></td></tr></table></figure></li></ul><h4 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h4><p><strong><code>gulp.task(name[,deps],fn)</code></strong></p><blockquote><p>上文示例也可以看出来，该函数主要用于定义一个任务(task).</p><blockquote><p><strong>name：</strong>任务的名字</p><p><strong>deps：</strong>列出在<strong>当前任务运行之前需要完成</strong>的任务列表</p><p><strong>fn：</strong>该任务的具体操作逻辑</p></blockquote></blockquote><p><strong><code>gulp.src(globs[,options])</code></strong></p><blockquote><p>输出符合模式(glob)或者匹配模式的数组的文件（<strong>其实和node-glob很像，都是汇聚符合某个glob的文件</strong>）</p><p>这个收集到数据可以做流的源，通过<code>.pipe</code>方法流的方式对数据源进行处理。</p><blockquote><p><strong>globs：</strong>匹配的规则</p><p><strong>options：</strong>配置项，是一个object类型</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; &gt; &#123;</span><br><span class="line">&gt; &gt;    buffer: boolean = <span class="literal">true</span>;<span class="comment">// 表示以buffer的形式返回文件内容，置成false则以stream的方式返回（大文件适用）。</span></span><br><span class="line">&gt; &gt;    read: boolean = <span class="literal">true</span>;<span class="comment">// 表示去读取文件内容，置成false则不读取返回空值</span></span><br><span class="line">&gt; &gt;    base: string; <span class="comment">// 查找的基准路径</span></span><br><span class="line">&gt; &gt; &#125;</span><br><span class="line">&gt; &gt;</span><br></pre></td></tr></table></figure></blockquote></blockquote><p><strong><code>gulp.dest(path[,options])</code></strong></p><blockquote><p>看名字就知道其意思，<code>gulp.src</code>是数据流的开始，<code>gulp.dest</code>可以是数据流的结束，中间适用pipe连接。</p><blockquote><p><strong>path：</strong>string|Function; 可以是个字符串路径或者返回一个路径的函数</p><p><strong>options：</strong>配置项，是一个object类型</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; &gt; &#123;</span><br><span class="line">&gt; &gt;     cwd: string = process.cwd(); <span class="comment">// 输出目录的cwd</span></span><br><span class="line">&gt; &gt;     mode: string = <span class="number">0777</span>; <span class="comment">// 定义所有在输出目录中所创建的目录的权限</span></span><br><span class="line">&gt; &gt; &#125;</span><br><span class="line">&gt; &gt;</span><br></pre></td></tr></table></figure></blockquote></blockquote><blockquote><p><strong>示例：</strong></p><blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; &gt; <span class="comment">// 收集src的js文件, copy一份到build下, build目录没有回自动创建</span></span><br><span class="line">&gt; &gt; gulp.src(<span class="string">"src/**/*.js"</span>).pipe(gulp.dest(<span class="string">"build"</span>));</span><br><span class="line">&gt; &gt;</span><br></pre></td></tr></table></figure></blockquote></blockquote><p><strong><code>gulp.watch(glob[,opts], tasks)</code></strong></p><blockquote><p>监听文件，在符合glob规则的文件发生改动的时候执行一个或者多个<code>gulp.task</code>创建的task的名字</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">var</span> watcher = gulp.watch(<span class="string">'js/**/*.js'</span>, [<span class="string">'uglify'</span>,<span class="string">'reload'</span>]);</span><br><span class="line">&gt; watcher.on(<span class="string">'change'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">&gt;   <span class="built_in">console</span>.log(<span class="string">'File '</span> + event.path + <span class="string">' was '</span> + event.type + <span class="string">', running tasks...'</span>);</span><br><span class="line">&gt; &#125;);</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p><strong><code>gulp.watch(glob[,opts,cb])</code></strong></p><blockquote><p>监听文件，在符合glob规则的文件发生改动的时候执行的callback</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; gulp.watch(<span class="string">'js/**/*.js'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">&gt;   <span class="built_in">console</span>.log(<span class="string">'File '</span> + event.path + <span class="string">' was '</span> + event.type + <span class="string">', running tasks...'</span>);</span><br><span class="line">&gt; &#125;);</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h2 id="场景收集"><a href="#场景收集" class="headerlink" title="场景收集"></a>场景收集</h2><ul><li><p>待补充</p><p>​</p></li></ul><h2 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h2><p><a href="https://gulpjs.com/" target="_blank" rel="noopener">gulp官网</a></p><p><a href="https://www.gulpjs.com.cn" target="_blank" rel="noopener">gulp中文网</a></p><p><a href="https://github.com/gulpjs/gulp" target="_blank" rel="noopener">gulp github库</a></p>]]></content>
    
    <summary type="html">
    
      gulp的基础和一些常用的使用场景列表
    
    </summary>
    
      <category term="node" scheme="http://fdconsole.com/categories/node/"/>
    
    
      <category term="node" scheme="http://fdconsole.com/tags/node/"/>
    
      <category term="gulp" scheme="http://fdconsole.com/tags/gulp/"/>
    
  </entry>
  
  <entry>
    <title>【webpack】: 记一次jsbundle体积优化</title>
    <link href="http://fdconsole.com/2018/03/07/%E3%80%90webpack%E3%80%91-%E8%AE%B0%E4%B8%80%E6%AC%A1jsbundle%E4%BD%93%E7%A7%AF%E4%BC%98%E5%8C%96/"/>
    <id>http://fdconsole.com/2018/03/07/【webpack】-记一次jsbundle体积优化/</id>
    <published>2018-03-07T12:05:26.000Z</published>
    <updated>2018-03-07T12:19:31.658Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近接到一个任务是帮忙优化jsbundle的体积，项目是用ts开发，多入口。在分析之后发现每个bundle都打了同一份代码(这份代码是其它组提供的ts，编译出来的js在3k左右)，而且是不经常变动的。</p><p>最初想到的就在打包的时候通过<a href="https://webpack.js.org/plugins/commons-chunk-plugin/" target="_blank" rel="noopener"><code>CommonChunkPlugin</code></a>或者<a href="https://webpack.js.org/plugins/dll-plugin/" target="_blank" rel="noopener"><code>Dll &amp; DllReference</code></a>插件来把这块提取出来，代码拆分做成一个独立的js，但是这样有个问题：就是每次其他组把这块代码更新的时候需要在工程里再跑一遍打包构建的过程，这就涉及到一个组更新了代码需要另外的组打包构建，在某些场景下是不可接受的。</p><hr><h2 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h2><p>在考虑了之后，决定将这部分公共的代码以<strong>库</strong>的方式提供出来，在提供给别人之后，打成单独的jsbundle，让别人在页面引。这就涉及到两次打bundle，那这两次打的bundle如何打通呢？</p><blockquote><p><strong>output.library + out.libraryTarget + externals的方式</strong></p></blockquote><h4 id="out-library-amp-out-libraryTarget"><a href="#out-library-amp-out-libraryTarget" class="headerlink" title="out.library &amp; out.libraryTarget"></a>out.library &amp; out.libraryTarget</h4><p><strong><a href="https://webpack.js.org/configuration/output/#output-library" target="_blank" rel="noopener">library</a>: </strong>配合libraryTarget使用。可以简单的看做这个库暴露给别人用的时候，关键词是啥。类比jQuery。<br><strong><a href="https://webpack.js.org/configuration/output/#output-librarytarget" target="_blank" rel="noopener">libraryTarget</a>: </strong>配合如何去暴露library。支持下面几种:</p><ul><li><p>通过var以变量的方式暴露出去。<strong>默认配置</strong></p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> &#123; </span><br><span class="line">   library: &apos;clam&apos;</span><br><span class="line"> &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>打出来的jsbundle就是 <code>var clam = /**_entry_return_*/;</code> 直接在页面引的话可能就直接挂window上了。</p></blockquote></li><li><p>通过<code>assign</code>可以将return挂载到已经存在的某个变量上。</p></li><li><p>通过其它一些变量的方式暴露出去。可以配置<code>this</code>,<code>global</code>,<code>commonjs</code>,<code>window</code>,这些配置加上library，就可以把对应的库<strong>挂载</strong>到这些变量上。对应的就是:</p><blockquote><p><code>this</code>  =&gt; <code>this[&#39;clam&#39;] = /**_entry_return_*/</code><br><code>global</code> =&gt; <code>global[&#39;clam&#39;] = /**_entry_return_*/</code><br><code>window</code> =&gt; <code>window[&#39;clam&#39;] = /**_entry_return_*/</code><br><code>commonjs</code> =&gt; <code>exports[&#39;clam&#39;] = /**_entry_return_*/</code></p></blockquote></li></ul><p>通过上述两个配置就解决了打库文件的文件，<strong>但是当时不想把太多的东西挂载到window上，就利用了assign的方式挂载在一个变量底下。</strong>即：</p><blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   library: <span class="string">`$VAR['clam']`</span>,</span><br><span class="line">   libraryTarget: <span class="string">`assign`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><hr><h4 id="externals"><a href="#externals" class="headerlink" title="externals"></a>externals</h4><p>使用assign的方式只会，返回值会挂载在$VAR[‘clam’]上，在打包的时候需要<strong>建立起与这个”库”的连接</strong>并且<strong>排除这个bundle</strong>就好。这个时候就该<a href="https://doc.webpack-china.org/configuration/externals/#object" target="_blank" rel="noopener">externals</a>出场了。</p><p>externals的配置主要就是为了解决上述说的两个问题：</p><ul><li>打的bundle里排除指定的库</li><li>建立与这个库的”连接”</li></ul><p>具体的配置可以看下<a href="https://doc.webpack-china.org/configuration/externals/" target="_blank" rel="noopener">官方文档</a>，不同的配置方式只是应对不同的场景，作用还是上面提到的两点。</p><p>比如我们利用<code>output.library &amp; output.libraryTarget</code>发布的包名叫Lib，使用的方式是<code>import {xxx} from &#39;Lib&#39;;</code>其所有的实现都已经挂载了$VAR[‘clam’] 上，那我们可以像下面这样配置externals：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">externals:&#123;</span><br><span class="line">  <span class="string">'Lib'</span>: <span class="string">`$VAR['clam']`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样生成的jsbundle里如下的方式：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">var</span> xxx = webpack_require(<span class="string">`$VAR['clam']`</span>);</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这篇记录主要记录了一次利用<code>output.library &amp; output.libraryTarget &amp; externals</code>来以库的方式将每个bundle的js减少3k还是不错的。</p><p>具体怎么打一个库可以看看<a href="https://doc.webpack-china.org/guides/author-libraries" target="_blank" rel="noopener">创建Library</a>文档。不同的配置可以将你的库打成一个<strong>commonjs库</strong>，<strong>es2015库</strong>甚至是一个<strong>UMD库</strong>。</p>]]></content>
    
    <summary type="html">
    
      记录了一次利用`output.library &amp; output.libraryTarget &amp; externals`优化jsbundle体积的过程
    
    </summary>
    
      <category term="webpack" scheme="http://fdconsole.com/categories/webpack/"/>
    
    
      <category term="webpack" scheme="http://fdconsole.com/tags/webpack/"/>
    
      <category term="javascript" scheme="http://fdconsole.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>JS数组：push vs concat</title>
    <link href="http://fdconsole.com/2018/03/06/JS%E6%95%B0%E7%BB%84%EF%BC%9Apush-vs-concat/"/>
    <id>http://fdconsole.com/2018/03/06/JS数组：push-vs-concat/</id>
    <published>2018-03-06T14:07:12.000Z</published>
    <updated>2018-03-07T12:14:30.459Z</updated>
    
    <content type="html"><![CDATA[<p>使用JS这么久, 对于JS数组的相关方法一直都是拿来就用,对于<code>push</code>方法更是常用。但是在一次用到<code>contact</code>方法的时候自问了一句: <code>push</code>和<code>contact</code>到底有哪些区别?</p><p><strong>先看下MDN的定义:</strong></p><blockquote><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/push" target="_blank" rel="noopener">【<code>push</code>】</a>:adds one or more elements to the end of an array and <strong>returns the new length</strong> of the array.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> animals = [<span class="string">'pigs'</span>, <span class="string">'goats'</span>, <span class="string">'sheep'</span>];</span><br><span class="line"><span class="built_in">console</span>.log(animals.push(<span class="string">'cows'</span>)); <span class="comment">// expected output: 4</span></span><br><span class="line"><span class="built_in">console</span>.log(animals); <span class="comment">// expected output: Array ["pigs", "goats", "sheep", "cows"]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">animals.push([<span class="string">'new arr'</span>]); <span class="comment">// expected output: 5</span></span><br><span class="line"><span class="built_in">console</span>.log(animals); <span class="comment">// expected output: Array ["pigs", "goats", "sheep", "cows", Array(1)]</span></span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/concat" target="_blank" rel="noopener">【<code>contact</code>】</a>:The <code>concat()</code> method is used to merge two or more arrays. This method <strong>does not change the existing arrays</strong>, but instead returns a new array.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array1 = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line"><span class="keyword">var</span> array2 = [<span class="string">'d'</span>, <span class="string">'e'</span>, <span class="string">'f'</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(array1.concat(array2)); <span class="comment">// expected output: Array ["a", "b", "c", "d", "e", "f"]</span></span><br><span class="line"><span class="built_in">console</span>.log(array1); <span class="comment">// expected output: Array ["a", "b", "c"]</span></span><br><span class="line"><span class="built_in">console</span>.log(array2); <span class="comment">// expected output: Array ["d", "e", "f"]</span></span><br></pre></td></tr></table></figure></p></blockquote><p><strong>摘取重点：</strong></p><ol><li><code>push</code>方法添加元素到数组末尾，改变的是同一个数组, 返回值是添加之后数组的长度</li><li><code>contact</code>方法是合并两个或者多个数组，不会改变存在的数组，返回的是合并的数组</li></ol><hr><p><strong>那性能会不会有区别?</strong></p><p>环境：win8.1 chrome 63.0.3239.132</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// push demo</span></span><br><span class="line"><span class="keyword">var</span> arr3 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> arr4 = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line"><span class="built_in">console</span>.time(<span class="string">'push'</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> index = <span class="number">10000</span>; index &gt; <span class="number">0</span>; index--) &#123;</span><br><span class="line">  arr3.push(...arr4);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.timeEnd(<span class="string">'push'</span>); <span class="comment">// push: 2.39892578125ms</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// contact demo</span></span><br><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> arr2 = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line"><span class="built_in">console</span>.time(<span class="string">'contact'</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> index = <span class="number">10000</span>; index &gt; <span class="number">0</span>; index--) &#123;</span><br><span class="line">  arr1 = arr1.concat(arr2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.timeEnd(<span class="string">'contact'</span>); <span class="comment">// contact: 312.762939453125ms</span></span><br></pre></td></tr></table></figure><p><strong>在我这个环境上push+解构的性能是要好于contact的。不过对于多个数组合并的时候, contact因为返回的是新数组，可以链式下去。</strong></p>]]></content>
    
    <summary type="html">
    
      了解JS数组push和concat的区别
    
    </summary>
    
      <category term="JS基础" scheme="http://fdconsole.com/categories/JS%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="javascript" scheme="http://fdconsole.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>我为什么要搭这个博客</title>
    <link href="http://fdconsole.com/2018/03/04/%E6%88%91%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%90%AD%E8%BF%99%E4%B8%AA%E5%8D%9A%E5%AE%A2/"/>
    <id>http://fdconsole.com/2018/03/04/我为什么要搭这个博客/</id>
    <published>2018-03-04T14:16:16.000Z</published>
    <updated>2018-03-07T12:14:27.340Z</updated>
    
    <content type="html"><![CDATA[<p>自16年毕业至今快工作两年了，写博客的念头在我的脑海里出现过无数次，但是确实是因为事情太多，再加上公司对开源管理的特殊性（使用的都是自己研究的框架，git版本管理也是内部仓库，所有的提交记录都是内部的），导致写博客的事情一而再再而三的被耽搁。😢</p><p>最近房子的事情终于搞完了，虽然工作依然很忙，但是本着自己对开源的热情还是强迫自己抽时间出来把平时接触的都记录一下，便于自己回顾，也希望能分享给其它人，更希望能让自己从新参与到开源的世界中。😂</p><p>这也是搭建这个博客的意义所在。😆</p>]]></content>
    
    <summary type="html">
    
      搭这个博客的意义
    
    </summary>
    
      <category term="非技术" scheme="http://fdconsole.com/categories/%E9%9D%9E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="唠叨" scheme="http://fdconsole.com/tags/%E5%94%A0%E5%8F%A8/"/>
    
  </entry>
  
</feed>
