<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Clam&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://fdconsole.com/"/>
  <updated>2018-04-16T17:06:40.445Z</updated>
  <id>http://fdconsole.com/</id>
  
  <author>
    <name>clam</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>SGML介绍 (翻译)</title>
    <link href="http://fdconsole.com/2018/04/17/SGML%E4%BB%8B%E7%BB%8D/"/>
    <id>http://fdconsole.com/2018/04/17/SGML介绍/</id>
    <published>2018-04-16T16:57:02.000Z</published>
    <updated>2018-04-16T17:06:40.445Z</updated>
    
    <content type="html"><![CDATA[<p>原文：<a href="https://validator.w3.org/docs/sgml.html" target="_blank" rel="noopener">Introduction to SGMLfor the W3C Markup Validator</a></p><h3 id="SGML是什么？"><a href="#SGML是什么？" class="headerlink" title="SGML是什么？"></a>SGML是什么？</h3><p>SGML是 Standard Generalized Markup Language 的缩写。这实际上有一点稍微的不合适，因为SGML实际上是一种<strong>元语言（meta-language）</strong>，即用于编写标记语言的语言。像我们熟知的HTML，在H5以前的版本就是基于SGML的，还有XHTML，XML等。</p><p>实际上并不需要知道很多SGML就可以很好的使用它的校验能力。但是如果你感兴趣，我建议TEI的 <a href="http://www.tei-c.org/Vault/P4/doc/html/SG.html" target="_blank" rel="noopener">SGML简介</a> 可以作为一个很好的起点。想更进一步，可以看看 Martin Bryan 的 <a href="http://www.is-thought.co.uk/book/home.htm" target="_blank" rel="noopener">Web SGML和HTML4.0解释</a>。</p><h3 id="DTD是什么"><a href="#DTD是什么" class="headerlink" title="DTD是什么?"></a>DTD是什么?</h3><p>出于我们的目的，DTD（文档类型定义）只是一个基于SGML定义的一个语法文件。HTML2.0 和 HTML3.2 的DTD是由IETF的HTML工作组与W3C合作撰写的。从 HTML4.0 开始（包含XHTML）是由W3C编写的。</p><h3 id="DOCTYPE-是什么？"><a href="#DOCTYPE-是什么？" class="headerlink" title="DOCTYPE 是什么？"></a>DOCTYPE 是什么？</h3><p><code>DOCTYPE</code>是 SGML 文档类型声明。它存在的目的是告诉SGML解析器应该使用哪种 DTD来解析文档。正常情况下作为文章的第一行显示。并具有以下格式：<code>&lt;!DOCTYPE html PUBLIC &quot;quoted string&quot;&gt;</code>。 其中 “quoted string” 被称为公共标识符，它通过一些熟知的名字来引用 标准的DTD。</p><h3 id="为什么要添加一个DOCTYPE？"><a href="#为什么要添加一个DOCTYPE？" class="headerlink" title="为什么要添加一个DOCTYPE？"></a>为什么要添加一个DOCTYPE？</h3><p>校验的能力是由SGML解释器提供的，而<code>DOCTYPE</code>声明即使不是唯一的方式知道应该验证哪些标记语言，也算是最主要的方式了。</p><p>需要注意的是，实际上大多数的浏览器并没有使用SGML解释器，它们大多数都是通过文档的<code>DOCTYPE</code>声明或是否缺少声明来显示文档内容的。这算是给文档添加声明的好理由吧。(译者注: <code>DOCTYPE</code>指示 web 浏览器关于页面使用哪个 HTML 版本进行编写的指令, HTML5不基于SGML, 所以H5的<code>DOCTYPE</code>不用公共标识符。)</p><p>所以现在我们应该给文档都添加一个<code>DOCTYPE</code>，并且确保语法正确，并且使用正确的公共标识符，否则的话，校验器就会使用错误的DTD，或者根本找不到DTD，从而导致一系列无意义的错误。</p><h3 id="我如何添加DOCTYPE声明？"><a href="#我如何添加DOCTYPE声明？" class="headerlink" title="我如何添加DOCTYPE声明？"></a>我如何添加DOCTYPE声明？</h3><p>可以参见W3C维护的DTD列表，详见 <a href="https://www.w3.org/QA/2002/04/valid-dtd-list.html" target="_blank" rel="noopener">DTD list</a></p>]]></content>
    
    <summary type="html">
    
      SGML是 Standard Generalized Markup Language 的缩写。这实际上有一点稍微的不合适，因为SGML实际上是一种元语言（meta-language），即用于编写标记语言的语言。像我们熟知的HTML，在H5以前的版本就是基于SGML的，还有XHTML，XML等。
    
    </summary>
    
      <category term="HTML" scheme="http://fdconsole.com/categories/HTML/"/>
    
    
      <category term="W3C" scheme="http://fdconsole.com/tags/W3C/"/>
    
      <category term="SGML" scheme="http://fdconsole.com/tags/SGML/"/>
    
  </entry>
  
  <entry>
    <title>常用的node库——gulp</title>
    <link href="http://fdconsole.com/2018/03/28/%E5%B8%B8%E7%94%A8%E7%9A%84node%E5%BA%93%E2%80%94%E2%80%94gulp/"/>
    <id>http://fdconsole.com/2018/03/28/常用的node库——gulp/</id>
    <published>2018-03-28T14:32:48.000Z</published>
    <updated>2018-03-28T14:35:26.092Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>gulp是基于Node的前端构建工具。将源到目标的编译构建按照流的思想任务化，正如其官网所说，gulp让简单的任务简单，让复杂的任务可管理。</p><h2 id="基础使用"><a href="#基础使用" class="headerlink" title="基础使用"></a>基础使用</h2><p><strong>1. 安装</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install -g gulp // 全局安装</span><br><span class="line">npm install -D gulp // 开发态依赖</span><br></pre></td></tr></table></figure><p><strong>2. 使用</strong></p><ul><li><p>在项目根目录新建<code>gulpfile.js</code>，内容格式如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>);</span><br><span class="line">gulp.task(<span class="string">'default'</span>, ()=&gt;&#123;</span><br><span class="line">    <span class="comment">// 任务代码</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'default task'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gulp // 执行gulpfile.js文件</span><br><span class="line">===&gt; default task</span><br><span class="line"></span><br><span class="line">gulp &lt;task&gt; &lt;othertask&gt; // 执行特定的任务</span><br></pre></td></tr></table></figure></li></ul><h4 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h4><p><strong><code>gulp.task(name[,deps],fn)</code></strong></p><blockquote><p>上文示例也可以看出来，该函数主要用于定义一个任务(task).</p><blockquote><p><strong>name：</strong>任务的名字</p><p><strong>deps：</strong>列出在<strong>当前任务运行之前需要完成</strong>的任务列表</p><p><strong>fn：</strong>该任务的具体操作逻辑</p></blockquote></blockquote><p><strong><code>gulp.src(globs[,options])</code></strong></p><blockquote><p>输出符合模式(glob)或者匹配模式的数组的文件（<strong>其实和node-glob很像，都是汇聚符合某个glob的文件</strong>）</p><p>这个收集到数据可以做流的源，通过<code>.pipe</code>方法流的方式对数据源进行处理。</p><blockquote><p><strong>globs：</strong>匹配的规则</p><p><strong>options：</strong>配置项，是一个object类型</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; &gt; &#123;</span><br><span class="line">&gt; &gt;    buffer: boolean = <span class="literal">true</span>;<span class="comment">// 表示以buffer的形式返回文件内容，置成false则以stream的方式返回（大文件适用）。</span></span><br><span class="line">&gt; &gt;    read: boolean = <span class="literal">true</span>;<span class="comment">// 表示去读取文件内容，置成false则不读取返回空值</span></span><br><span class="line">&gt; &gt;    base: string; <span class="comment">// 查找的基准路径</span></span><br><span class="line">&gt; &gt; &#125;</span><br><span class="line">&gt; &gt;</span><br></pre></td></tr></table></figure></blockquote></blockquote><p><strong><code>gulp.dest(path[,options])</code></strong></p><blockquote><p>看名字就知道其意思，<code>gulp.src</code>是数据流的开始，<code>gulp.dest</code>可以是数据流的结束，中间适用pipe连接。</p><blockquote><p><strong>path：</strong>string|Function; 可以是个字符串路径或者返回一个路径的函数</p><p><strong>options：</strong>配置项，是一个object类型</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; &gt; &#123;</span><br><span class="line">&gt; &gt;     cwd: string = process.cwd(); <span class="comment">// 输出目录的cwd</span></span><br><span class="line">&gt; &gt;     mode: string = <span class="number">0777</span>; <span class="comment">// 定义所有在输出目录中所创建的目录的权限</span></span><br><span class="line">&gt; &gt; &#125;</span><br><span class="line">&gt; &gt;</span><br></pre></td></tr></table></figure></blockquote></blockquote><blockquote><p><strong>示例：</strong></p><blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; &gt; <span class="comment">// 收集src的js文件, copy一份到build下, build目录没有回自动创建</span></span><br><span class="line">&gt; &gt; gulp.src(<span class="string">"src/**/*.js"</span>).pipe(gulp.dest(<span class="string">"build"</span>));</span><br><span class="line">&gt; &gt;</span><br></pre></td></tr></table></figure></blockquote></blockquote><p><strong><code>gulp.watch(glob[,opts], tasks)</code></strong></p><blockquote><p>监听文件，在符合glob规则的文件发生改动的时候执行一个或者多个<code>gulp.task</code>创建的task的名字</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">var</span> watcher = gulp.watch(<span class="string">'js/**/*.js'</span>, [<span class="string">'uglify'</span>,<span class="string">'reload'</span>]);</span><br><span class="line">&gt; watcher.on(<span class="string">'change'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">&gt;   <span class="built_in">console</span>.log(<span class="string">'File '</span> + event.path + <span class="string">' was '</span> + event.type + <span class="string">', running tasks...'</span>);</span><br><span class="line">&gt; &#125;);</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p><strong><code>gulp.watch(glob[,opts,cb])</code></strong></p><blockquote><p>监听文件，在符合glob规则的文件发生改动的时候执行的callback</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; gulp.watch(<span class="string">'js/**/*.js'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">&gt;   <span class="built_in">console</span>.log(<span class="string">'File '</span> + event.path + <span class="string">' was '</span> + event.type + <span class="string">', running tasks...'</span>);</span><br><span class="line">&gt; &#125;);</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h2 id="场景收集"><a href="#场景收集" class="headerlink" title="场景收集"></a>场景收集</h2><ul><li><p>待补充</p><p>​</p></li></ul><h2 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h2><p><a href="https://gulpjs.com/" target="_blank" rel="noopener">gulp官网</a></p><p><a href="https://www.gulpjs.com.cn" target="_blank" rel="noopener">gulp中文网</a></p><p><a href="https://github.com/gulpjs/gulp" target="_blank" rel="noopener">gulp github库</a></p>]]></content>
    
    <summary type="html">
    
      gulp的基础和一些常用的使用场景列表
    
    </summary>
    
      <category term="node" scheme="http://fdconsole.com/categories/node/"/>
    
    
      <category term="node" scheme="http://fdconsole.com/tags/node/"/>
    
      <category term="gulp" scheme="http://fdconsole.com/tags/gulp/"/>
    
  </entry>
  
  <entry>
    <title>【webpack】: 记一次jsbundle体积优化</title>
    <link href="http://fdconsole.com/2018/03/07/%E3%80%90webpack%E3%80%91-%E8%AE%B0%E4%B8%80%E6%AC%A1jsbundle%E4%BD%93%E7%A7%AF%E4%BC%98%E5%8C%96/"/>
    <id>http://fdconsole.com/2018/03/07/【webpack】-记一次jsbundle体积优化/</id>
    <published>2018-03-07T12:05:26.000Z</published>
    <updated>2018-03-07T12:19:31.658Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近接到一个任务是帮忙优化jsbundle的体积，项目是用ts开发，多入口。在分析之后发现每个bundle都打了同一份代码(这份代码是其它组提供的ts，编译出来的js在3k左右)，而且是不经常变动的。</p><p>最初想到的就在打包的时候通过<a href="https://webpack.js.org/plugins/commons-chunk-plugin/" target="_blank" rel="noopener"><code>CommonChunkPlugin</code></a>或者<a href="https://webpack.js.org/plugins/dll-plugin/" target="_blank" rel="noopener"><code>Dll &amp; DllReference</code></a>插件来把这块提取出来，代码拆分做成一个独立的js，但是这样有个问题：就是每次其他组把这块代码更新的时候需要在工程里再跑一遍打包构建的过程，这就涉及到一个组更新了代码需要另外的组打包构建，在某些场景下是不可接受的。</p><hr><h2 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h2><p>在考虑了之后，决定将这部分公共的代码以<strong>库</strong>的方式提供出来，在提供给别人之后，打成单独的jsbundle，让别人在页面引。这就涉及到两次打bundle，那这两次打的bundle如何打通呢？</p><blockquote><p><strong>output.library + out.libraryTarget + externals的方式</strong></p></blockquote><h4 id="out-library-amp-out-libraryTarget"><a href="#out-library-amp-out-libraryTarget" class="headerlink" title="out.library &amp; out.libraryTarget"></a>out.library &amp; out.libraryTarget</h4><p><strong><a href="https://webpack.js.org/configuration/output/#output-library" target="_blank" rel="noopener">library</a>: </strong>配合libraryTarget使用。可以简单的看做这个库暴露给别人用的时候，关键词是啥。类比jQuery。<br><strong><a href="https://webpack.js.org/configuration/output/#output-librarytarget" target="_blank" rel="noopener">libraryTarget</a>: </strong>配合如何去暴露library。支持下面几种:</p><ul><li><p>通过var以变量的方式暴露出去。<strong>默认配置</strong></p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> &#123; </span><br><span class="line">   library: &apos;clam&apos;</span><br><span class="line"> &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>打出来的jsbundle就是 <code>var clam = /**_entry_return_*/;</code> 直接在页面引的话可能就直接挂window上了。</p></blockquote></li><li><p>通过<code>assign</code>可以将return挂载到已经存在的某个变量上。</p></li><li><p>通过其它一些变量的方式暴露出去。可以配置<code>this</code>,<code>global</code>,<code>commonjs</code>,<code>window</code>,这些配置加上library，就可以把对应的库<strong>挂载</strong>到这些变量上。对应的就是:</p><blockquote><p><code>this</code>  =&gt; <code>this[&#39;clam&#39;] = /**_entry_return_*/</code><br><code>global</code> =&gt; <code>global[&#39;clam&#39;] = /**_entry_return_*/</code><br><code>window</code> =&gt; <code>window[&#39;clam&#39;] = /**_entry_return_*/</code><br><code>commonjs</code> =&gt; <code>exports[&#39;clam&#39;] = /**_entry_return_*/</code></p></blockquote></li></ul><p>通过上述两个配置就解决了打库文件的文件，<strong>但是当时不想把太多的东西挂载到window上，就利用了assign的方式挂载在一个变量底下。</strong>即：</p><blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   library: <span class="string">`$VAR['clam']`</span>,</span><br><span class="line">   libraryTarget: <span class="string">`assign`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><hr><h4 id="externals"><a href="#externals" class="headerlink" title="externals"></a>externals</h4><p>使用assign的方式只会，返回值会挂载在$VAR[‘clam’]上，在打包的时候需要<strong>建立起与这个”库”的连接</strong>并且<strong>排除这个bundle</strong>就好。这个时候就该<a href="https://doc.webpack-china.org/configuration/externals/#object" target="_blank" rel="noopener">externals</a>出场了。</p><p>externals的配置主要就是为了解决上述说的两个问题：</p><ul><li>打的bundle里排除指定的库</li><li>建立与这个库的”连接”</li></ul><p>具体的配置可以看下<a href="https://doc.webpack-china.org/configuration/externals/" target="_blank" rel="noopener">官方文档</a>，不同的配置方式只是应对不同的场景，作用还是上面提到的两点。</p><p>比如我们利用<code>output.library &amp; output.libraryTarget</code>发布的包名叫Lib，使用的方式是<code>import {xxx} from &#39;Lib&#39;;</code>其所有的实现都已经挂载了$VAR[‘clam’] 上，那我们可以像下面这样配置externals：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">externals:&#123;</span><br><span class="line">  <span class="string">'Lib'</span>: <span class="string">`$VAR['clam']`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样生成的jsbundle里如下的方式：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">var</span> xxx = webpack_require(<span class="string">`$VAR['clam']`</span>);</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这篇记录主要记录了一次利用<code>output.library &amp; output.libraryTarget &amp; externals</code>来以库的方式将每个bundle的js减少3k还是不错的。</p><p>具体怎么打一个库可以看看<a href="https://doc.webpack-china.org/guides/author-libraries" target="_blank" rel="noopener">创建Library</a>文档。不同的配置可以将你的库打成一个<strong>commonjs库</strong>，<strong>es2015库</strong>甚至是一个<strong>UMD库</strong>。</p>]]></content>
    
    <summary type="html">
    
      记录了一次利用`output.library &amp; output.libraryTarget &amp; externals`优化jsbundle体积的过程
    
    </summary>
    
      <category term="webpack" scheme="http://fdconsole.com/categories/webpack/"/>
    
    
      <category term="javascript" scheme="http://fdconsole.com/tags/javascript/"/>
    
      <category term="webpack" scheme="http://fdconsole.com/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>JS数组：push vs concat</title>
    <link href="http://fdconsole.com/2018/03/06/JS%E6%95%B0%E7%BB%84%EF%BC%9Apush-vs-concat/"/>
    <id>http://fdconsole.com/2018/03/06/JS数组：push-vs-concat/</id>
    <published>2018-03-06T14:07:12.000Z</published>
    <updated>2018-03-07T12:14:30.459Z</updated>
    
    <content type="html"><![CDATA[<p>使用JS这么久, 对于JS数组的相关方法一直都是拿来就用,对于<code>push</code>方法更是常用。但是在一次用到<code>contact</code>方法的时候自问了一句: <code>push</code>和<code>contact</code>到底有哪些区别?</p><p><strong>先看下MDN的定义:</strong></p><blockquote><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/push" target="_blank" rel="noopener">【<code>push</code>】</a>:adds one or more elements to the end of an array and <strong>returns the new length</strong> of the array.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> animals = [<span class="string">'pigs'</span>, <span class="string">'goats'</span>, <span class="string">'sheep'</span>];</span><br><span class="line"><span class="built_in">console</span>.log(animals.push(<span class="string">'cows'</span>)); <span class="comment">// expected output: 4</span></span><br><span class="line"><span class="built_in">console</span>.log(animals); <span class="comment">// expected output: Array ["pigs", "goats", "sheep", "cows"]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">animals.push([<span class="string">'new arr'</span>]); <span class="comment">// expected output: 5</span></span><br><span class="line"><span class="built_in">console</span>.log(animals); <span class="comment">// expected output: Array ["pigs", "goats", "sheep", "cows", Array(1)]</span></span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/concat" target="_blank" rel="noopener">【<code>contact</code>】</a>:The <code>concat()</code> method is used to merge two or more arrays. This method <strong>does not change the existing arrays</strong>, but instead returns a new array.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array1 = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line"><span class="keyword">var</span> array2 = [<span class="string">'d'</span>, <span class="string">'e'</span>, <span class="string">'f'</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(array1.concat(array2)); <span class="comment">// expected output: Array ["a", "b", "c", "d", "e", "f"]</span></span><br><span class="line"><span class="built_in">console</span>.log(array1); <span class="comment">// expected output: Array ["a", "b", "c"]</span></span><br><span class="line"><span class="built_in">console</span>.log(array2); <span class="comment">// expected output: Array ["d", "e", "f"]</span></span><br></pre></td></tr></table></figure></p></blockquote><p><strong>摘取重点：</strong></p><ol><li><code>push</code>方法添加元素到数组末尾，改变的是同一个数组, 返回值是添加之后数组的长度</li><li><code>contact</code>方法是合并两个或者多个数组，不会改变存在的数组，返回的是合并的数组</li></ol><hr><p><strong>那性能会不会有区别?</strong></p><p>环境：win8.1 chrome 63.0.3239.132</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// push demo</span></span><br><span class="line"><span class="keyword">var</span> arr3 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> arr4 = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line"><span class="built_in">console</span>.time(<span class="string">'push'</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> index = <span class="number">10000</span>; index &gt; <span class="number">0</span>; index--) &#123;</span><br><span class="line">  arr3.push(...arr4);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.timeEnd(<span class="string">'push'</span>); <span class="comment">// push: 2.39892578125ms</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// contact demo</span></span><br><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> arr2 = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line"><span class="built_in">console</span>.time(<span class="string">'contact'</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> index = <span class="number">10000</span>; index &gt; <span class="number">0</span>; index--) &#123;</span><br><span class="line">  arr1 = arr1.concat(arr2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.timeEnd(<span class="string">'contact'</span>); <span class="comment">// contact: 312.762939453125ms</span></span><br></pre></td></tr></table></figure><p><strong>在我这个环境上push+解构的性能是要好于contact的。不过对于多个数组合并的时候, contact因为返回的是新数组，可以链式下去。</strong></p>]]></content>
    
    <summary type="html">
    
      了解JS数组push和concat的区别
    
    </summary>
    
      <category term="JS基础" scheme="http://fdconsole.com/categories/JS%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="javascript" scheme="http://fdconsole.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>我为什么要搭这个博客</title>
    <link href="http://fdconsole.com/2018/03/04/%E6%88%91%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%90%AD%E8%BF%99%E4%B8%AA%E5%8D%9A%E5%AE%A2/"/>
    <id>http://fdconsole.com/2018/03/04/我为什么要搭这个博客/</id>
    <published>2018-03-04T14:16:16.000Z</published>
    <updated>2018-03-07T12:14:27.340Z</updated>
    
    <content type="html"><![CDATA[<p>自16年毕业至今快工作两年了，写博客的念头在我的脑海里出现过无数次，但是确实是因为事情太多，再加上公司对开源管理的特殊性（使用的都是自己研究的框架，git版本管理也是内部仓库，所有的提交记录都是内部的），导致写博客的事情一而再再而三的被耽搁。😢</p><p>最近房子的事情终于搞完了，虽然工作依然很忙，但是本着自己对开源的热情还是强迫自己抽时间出来把平时接触的都记录一下，便于自己回顾，也希望能分享给其它人，更希望能让自己从新参与到开源的世界中。😂</p><p>这也是搭建这个博客的意义所在。😆</p>]]></content>
    
    <summary type="html">
    
      搭这个博客的意义
    
    </summary>
    
      <category term="非技术" scheme="http://fdconsole.com/categories/%E9%9D%9E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="唠叨" scheme="http://fdconsole.com/tags/%E5%94%A0%E5%8F%A8/"/>
    
  </entry>
  
</feed>
